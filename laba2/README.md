# Відповіді на контрольні питання з Java

## 1. Різниця між ключовими та зарезервованими словами

**Ключові слова (keywords)** - це слова, які мають спеціальне значення в мові Java і використовуються для певних конструкцій. Наприклад: `class`, `if`, `for`, `public`, `static`, `void`.

**Зарезервовані слова (reserved words)** - це слова, які зарезервовані для майбутнього використання, але поки що не мають функціональності в Java. Наприклад: `goto`, `const`.

Всі ключові слова є зарезервованими, але не всі зарезервовані слова є ключовими.

## 2. Примітивні типи даних та їх використання

| Тип | Розмір | Приклад використання |
|-----|--------|---------------------|
| `boolean` | 1 біт | Статус включення/виключення пристрою |
| `byte` | 1 байт | Обробка бінарних файлів, потоків даних |
| `char` | 2 байти | Зберігання одного символу Unicode |
| `short` | 2 байти | Економія пам'яті при роботі з невеликими числами |
| `int` | 4 байти | Рахунок у футбольному матчі, вік людини, кількість студентів |
| `long` | 8 байтів | Кількість зірок на небі, розмір файлу в байтах |
| `float` | 4 байти | Координати в іграх, не критичні обчислення |
| `double` | 8 байтів | Заробітна платня, наукові розрахунки, маса всесвіту |

## 3. Знакові та беззнакові типи

**Знакові типи** можуть зберігати як додатні, так і від'ємні значення:
- `byte`, `short`, `int`, `long`, `float`, `double`

**Беззнакові типи** зберігають тільки невід'ємні значення:
- `char` (технічно беззнаковий 16-бітний тип)
- `boolean` (не числовий тип)

*Примітка: В Java немає явних беззнакових числових типів, окрім char.*

## 4. Максимальні значення типів

| Тип | Максимальне значення |
|-----|---------------------|
| `short` | 32,767 (2¹⁵ - 1) |
| `char` | 65,535 (2¹⁶ - 1) |
| `int` | 2,147,483,647 (2³¹ - 1) |
| `long` | 9,223,372,036,854,775,807 (2⁶³ - 1) |

## 5. Діапазон типу byte (-128..127)

Тип `byte` займає 8 біт, що дозволяє зберігати 2⁸ = 256 різних значень.

У знаковому представленні:
- Старший біт використовується для знаку (0 = додатне, 1 = від'ємне)
- Залишається 7 біт для значення

Розподіл значень:
- Додатні: 0 до 127 (128 значень, включаючи 0)
- Від'ємні: -128 до -1 (128 значень)

Від'ємних значень не більше - їх рівно стільки ж. Але через те, що 0 відноситься до невід'ємних, діапазон додатних менший.

## 6. Системи числення та переведення

**Система числення** - це спосіб запису чисел за допомогою певного набору символів.

Основні системи:
- Двійкова (основа 2): 0, 1
- Вісімкова (основа 8): 0-7  
- Десяткова (основа 10): 0-9
- Шістнадцяткова (основа 16): 0-9, A-F

**Переведення:**
- З будь-якої в десяткову: множити кожну цифру на основу в степені позиції
- З десяткової в будь-яку: ділити на основу, записувати залишки
- Між недесятковими: через десяткову як проміжну

## 7. Доповняльний код (Two's Complement)

Метод представлення від'ємних чисел у двійковій системі:

1. Записати двійковий код додатного числа
2. Інвертувати всі біти (0→1, 1→0)
3. Додати 1 до результату

Приклад для числа -5 (8-бітне представлення):
- 5 = 00000101
- Інверсія = 11111010  
- +1 = 11111011 = -5

## 8. Аналіз переповнення int

```java
int a = 2_000_000_000;
int b = 2_000_000_000;
int c = a + b;
System.out.println(c); // Результат: -294967296
```

**Пояснення:** Максимальне значення `int` = 2,147,483,647. Сума 4,000,000,000 перевищує цей ліміт, що призводить до переповнення (overflow). Результат "обертається" і стає від'ємним числом.

## 9. Різниця між float та double

| Характеристика | float | double |
|---------------|-------|--------|
| Розмір | 32 біти (4 байти) | 64 біти (8 байтів) |
| Точність | ~7 десяткових цифр | ~15-17 десяткових цифр |
| Діапазон | ±3.4 × 10³⁸ | ±1.7 × 10³⁰⁸ |
| Суфікс | f або F | d або D (необов'язково) |

## 10. Число з рухомою комою

**Число з рухомою комою** - спосіб представлення дійсних чисел у вигляді:
**±мантиса × основа^степінь**

**Мантиса** - частина, що містить значущі цифри числа
**Степінь (експонента)** - визначає позицію коми

Приклад: 123.456 = 1.23456 × 10²
- Мантиса: 1.23456
- Степінь: 2

## 11. Double.NaN

`Double.NaN` (Not a Number) - спеціальне значення, що представляє невизначений або нерепрезентабельний результат обчислень з плаваючою комою.

Виникає при:
- 0.0 / 0.0
- sqrt(-1)
- log(-1)
- acos(2)

## 12. Порівняння Double.NaN

```java
System.out.println(Double.NaN == Double.NaN); // false
```

**Пояснення:** За стандартом IEEE 754, NaN не дорівнює нічому, включаючи саме себе. Це унікальна властивість NaN. Для перевірки на NaN використовується `Double.isNaN()`.

## 13. Преінкремент vs Постінкремент

**Преінкремент (++x):** спочатку збільшує значення, потім повертає
**Постінкремент (x++):** спочатку повертає значення, потім збільшує

```java
int a = 5;
int b = ++a; // a = 6, b = 6

int c = 5;
int d = c++; // c = 6, d = 5

// Різниця в складних виразах:
int x = 5;
int result = x++ + ++x; // 5 + 7 = 12, x стає 7
```

## 14. Логічні vs Побітові операції AND

**Логічний AND (&&):**
- Працює з boolean значеннями
- Короткозамкнутий (якщо перший false, другий не обчислюється)
- Результат: true або false

**Побітовий AND (&):**
- Працює з бітами числових типів
- Завжди обчислює обидва операнди
- Результат: число з побітовою операцією

```java
// Логічний
boolean result1 = true && false; // false

// Побітовий
int result2 = 5 & 3; // 101 & 011 = 001 = 1
```

Короткозамкнута версія (&& ||) існує тільки для логічних операцій, тому що:
- В логіці часто потрібна оптимізація
- Побітові операції завжди потребують обидва операнди

## 15. Різниця між OR та XOR

**OR (|, ||):**
- Повертає true, якщо хоча б один операнд true
- 0|0=0, 0|1=1, 1|0=1, 1|1=1

**XOR (^):**
- Повертає true, якщо операнди різні
- 0^0=0, 0^1=1, 1^0=1, 1^1=0
- "Виключне АБО"

```java
// OR
true | false = true
5 | 3 = 101|011 = 111 = 7

// XOR  
true ^ false = true
5 ^ 3 = 101^011 = 110 = 6
```

## 16. Аналіз складного виразу

```java
boolean a = true && false | false;
System.out.println(a = false);
        
boolean b = true && false || false;
System.out.println(b = true);
```

**Аналіз першого виразу:**
1. `true && false | false`
2. Пріоритет: && вище за |
3. `(true && false) | false` = `false | false` = `false`
4. `a = false` - присвоєння і вивід `false`

**Аналіз другого виразу:**
1. `true && false || false`  
2. Пріоритет: && вище за ||
3. `(true && false) || false` = `false || false` = `false`
4. `b = true` - присвоєння true змінній b
5. Виводиться `true` (значення присвоєння)

**Результат виконання:**
```
false
true
```

**Пояснення:** У другому випадку оператор присвоєння `b = true` змінює значення b на true і повертає це значення для виводу, незалежно від попереднього обчислення.